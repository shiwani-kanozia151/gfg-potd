Count Indices to Balance Even and Odd Sums

Given an array arr[], count the number of indices such that deleting the element at that index and shifting all elements after it one position left results in an array 
where the sum of elements at even indices equals the sum at odd indices.

Examples:

Input: arr[] = [2, 1, 6, 4]
Output: 1
Explaination: After removing arr[1], the resulting array will be [2, 6, 4] the sums of elements at odd index is arr[1] = 6 and the sum of elements at even index is arr[0] + arr[2] = 6.

Input: arr[] = [1, 1, 1]
Output: 3
Explaination: Removing any element makes the sum of odd and even indexed elements equal.

Constraints:
1 ≤ arr.size() ≤ 10^5
0 ≤ arr[i] ≤ 10^4

CODE
class Solution {
public:
    int waysToMakeFair(vector<int>& nums) {
        int n = nums.size();
        
        int totalEven = 0, totalOdd = 0;

        // Step 1: calculate total even & odd sums
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0)
                totalEven += nums[i];
            else
                totalOdd += nums[i];
        }

        int leftEven = 0, leftOdd = 0;
        int count = 0;

        // Step 2: try removing each index
        for (int i = 0; i < n; i++) {

            // Remove current element from right side
            if (i % 2 == 0)
                totalEven -= nums[i];
            else
                totalOdd -= nums[i];

            // After removal, indices shift
            int newEvenSum = leftEven + totalOdd;
            int newOddSum  = leftOdd + totalEven;

            if (newEvenSum == newOddSum)
                count++;

            // Add current element to left side
            if (i % 2 == 0)
                leftEven += nums[i];
            else
                leftOdd += nums[i];
        }

        return count;
    }
};
